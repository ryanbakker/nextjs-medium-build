'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var sanityClient = require('@sanity/client');
var react = require('react');
var groq = require('groq');
function _interopDefaultLegacy(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    'default': e
  };
}
function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}
var sanityClient__default = /*#__PURE__*/_interopDefaultLegacy(sanityClient);
var groq__default = /*#__PURE__*/_interopDefaultLegacy(groq);
function createClient(config) {
  return sanityClient__default["default"](config);
}
class MockAbortController {
  constructor() {
    this._signal = {
      aborted: false
    };
  }
  get signal() {
    return this._signal;
  }
  abort() {
    this._signal.aborted = true;
  }
}
function getAborter() {
  return typeof AbortController === "undefined" ? new MockAbortController() : new AbortController();
}
function createCurrentUserHook(_ref) {
  let {
    projectId
  } = _ref;
  return () => useCurrentUser(projectId);
}
function getCurrentUser(projectId, abort, token) {
  const headers = token ? {
    Authorization: "Bearer ".concat(token)
  } : void 0;
  return fetch("https://".concat(projectId, ".api.sanity.io/v1/users/me"), {
    credentials: "include",
    signal: abort.signal,
    headers
  }).then(res => res.json()).then(res => (res == null ? void 0 : res.id) ? res : null);
}
function useCurrentUser(projectId) {
  const [data, setUser] = react.useState();
  const [error, setError] = react.useState();
  react.useEffect(() => {
    const aborter = getAborter();
    getCurrentUser(projectId, aborter).then(setUser).catch(err => err.name !== "AbortError" && setError(err));
    return () => {
      aborter.abort();
    };
  }, [projectId]);
  return {
    data,
    error,
    loading: data !== null || !error
  };
}
const EMPTY_PARAMS = {};
function createPreviewSubscriptionHook(_ref2) {
  let {
    projectId,
    dataset,
    token,
    EventSource,
    documentLimit = 3e3
  } = _ref2;
  let store;
  return function usePreviewSubscription(query) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      params = EMPTY_PARAMS,
      initialData,
      enabled
    } = options;
    return useQuerySubscription({
      getStore,
      projectId,
      query,
      params,
      initialData,
      enabled: enabled ? typeof window !== "undefined" : false,
      token
    });
  };
  function getStore(abort) {
    if (!store) {
      store = Promise.resolve().then(function () {
        return /*#__PURE__*/_interopNamespace(require('@sanity/groq-store'));
      }).then(_ref3 => {
        let {
          groqStore
        } = _ref3;
        if (abort.signal.aborted) {
          const error = new Error("Cancelling groq store creation");
          error.name = "AbortError";
          return Promise.reject(error);
        }
        return groqStore({
          projectId,
          dataset,
          documentLimit,
          token,
          EventSource,
          listen: true,
          overlayDrafts: true,
          subscriptionThrottleMs: 10
        });
      });
    }
    return store;
  }
}
function useQuerySubscription(options) {
  const {
    getStore,
    projectId,
    query,
    initialData,
    enabled = false,
    token
  } = options;
  const [error, setError] = react.useState();
  const [loading, setLoading] = react.useState(false);
  const [data, setData] = react.useState();
  const params = useParams(options.params);
  react.useEffect(() => {
    if (!enabled) {
      return;
    }
    setLoading(true);
    const aborter = getAborter();
    let subscription;
    getCurrentUser(projectId, aborter, token).then(user => {
      if (user) {
        return;
      }
      console.warn("Not authenticated - preview not available");
      throw new Error("Not authenticated - preview not available");
    }).then(() => getStore(aborter)).then(store => {
      subscription = store.subscribe(query, params, (err, result) => {
        if (err) {
          setError(err);
        } else {
          setData(result);
        }
      });
    }).catch(err => err.name === "AbortError" ? null : setError(err)).finally(() => setLoading(false));
    return () => {
      if (subscription) {
        subscription.unsubscribe();
      }
      aborter.abort();
    };
  }, [getStore, query, params, enabled, projectId, token]);
  return {
    data: typeof data === "undefined" ? initialData : data,
    loading,
    error
  };
}
function useParams(params) {
  const stringifiedParams = react.useMemo(() => JSON.stringify(params), [params]);
  return react.useMemo(() => JSON.parse(stringifiedParams), [stringifiedParams]);
}
Object.defineProperty(exports, 'groq', {
  enumerable: true,
  get: function () {
    return groq__default["default"];
  }
});
exports.createClient = createClient;
exports.createCurrentUserHook = createCurrentUserHook;
exports.createPreviewSubscriptionHook = createPreviewSubscriptionHook;
//# sourceMappingURL=index.js.map
