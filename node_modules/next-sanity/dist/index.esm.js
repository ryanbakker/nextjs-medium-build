import sanityClient from '@sanity/client';
import { useState, useEffect, useMemo } from 'react';
export { default as groq } from 'groq';
function createClient(config) {
  return sanityClient(config);
}
class MockAbortController {
  constructor() {
    this._signal = {
      aborted: false
    };
  }
  get signal() {
    return this._signal;
  }
  abort() {
    this._signal.aborted = true;
  }
}
function getAborter() {
  return typeof AbortController === "undefined" ? new MockAbortController() : new AbortController();
}
function createCurrentUserHook(_ref) {
  let {
    projectId
  } = _ref;
  return () => useCurrentUser(projectId);
}
function getCurrentUser(projectId, abort, token) {
  const headers = token ? {
    Authorization: "Bearer ".concat(token)
  } : void 0;
  return fetch("https://".concat(projectId, ".api.sanity.io/v1/users/me"), {
    credentials: "include",
    signal: abort.signal,
    headers
  }).then(res => res.json()).then(res => (res == null ? void 0 : res.id) ? res : null);
}
function useCurrentUser(projectId) {
  const [data, setUser] = useState();
  const [error, setError] = useState();
  useEffect(() => {
    const aborter = getAborter();
    getCurrentUser(projectId, aborter).then(setUser).catch(err => err.name !== "AbortError" && setError(err));
    return () => {
      aborter.abort();
    };
  }, [projectId]);
  return {
    data,
    error,
    loading: data !== null || !error
  };
}
const EMPTY_PARAMS = {};
function createPreviewSubscriptionHook(_ref2) {
  let {
    projectId,
    dataset,
    token,
    EventSource,
    documentLimit = 3e3
  } = _ref2;
  let store;
  return function usePreviewSubscription(query) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      params = EMPTY_PARAMS,
      initialData,
      enabled
    } = options;
    return useQuerySubscription({
      getStore,
      projectId,
      query,
      params,
      initialData,
      enabled: enabled ? typeof window !== "undefined" : false,
      token
    });
  };
  function getStore(abort) {
    if (!store) {
      store = import('@sanity/groq-store').then(_ref3 => {
        let {
          groqStore
        } = _ref3;
        if (abort.signal.aborted) {
          const error = new Error("Cancelling groq store creation");
          error.name = "AbortError";
          return Promise.reject(error);
        }
        return groqStore({
          projectId,
          dataset,
          documentLimit,
          token,
          EventSource,
          listen: true,
          overlayDrafts: true,
          subscriptionThrottleMs: 10
        });
      });
    }
    return store;
  }
}
function useQuerySubscription(options) {
  const {
    getStore,
    projectId,
    query,
    initialData,
    enabled = false,
    token
  } = options;
  const [error, setError] = useState();
  const [loading, setLoading] = useState(false);
  const [data, setData] = useState();
  const params = useParams(options.params);
  useEffect(() => {
    if (!enabled) {
      return;
    }
    setLoading(true);
    const aborter = getAborter();
    let subscription;
    getCurrentUser(projectId, aborter, token).then(user => {
      if (user) {
        return;
      }
      console.warn("Not authenticated - preview not available");
      throw new Error("Not authenticated - preview not available");
    }).then(() => getStore(aborter)).then(store => {
      subscription = store.subscribe(query, params, (err, result) => {
        if (err) {
          setError(err);
        } else {
          setData(result);
        }
      });
    }).catch(err => err.name === "AbortError" ? null : setError(err)).finally(() => setLoading(false));
    return () => {
      if (subscription) {
        subscription.unsubscribe();
      }
      aborter.abort();
    };
  }, [getStore, query, params, enabled, projectId, token]);
  return {
    data: typeof data === "undefined" ? initialData : data,
    loading,
    error
  };
}
function useParams(params) {
  const stringifiedParams = useMemo(() => JSON.stringify(params), [params]);
  return useMemo(() => JSON.parse(stringifiedParams), [stringifiedParams]);
}
export { createClient, createCurrentUserHook, createPreviewSubscriptionHook };
//# sourceMappingURL=index.esm.js.map
